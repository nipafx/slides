=== Structured programming

* prescribes single entry point +
  and clearly defined exit points
* influenced languages and runtimes

=== Structured concurrency

> When the flow of execution splits into multiple concurrent flows, they rejoin in the same code block.

⇝ Threads are short-lived:

* start when task begins
* end on completion

⇝ Enables parent-child/sibling relationships +
  and logical grouping of threads.

=== Structured concurrency

```java
String executeTasks() throws InterruptedException {
	// implicitly short-circuits on error
	try (var scope = StructuredTaskScope.open()) {
		Subtask<String> taskA = scope.fork(this::doA);
		Subtask<String> taskB = scope.fork(this::doB);

		// wait explicitly for success
		// (throws errors if there were any)
		scope.join();

		// all tasks succeeded
		return taskA.get() + taskB.get();
	} catch (FailedException ex) {
		return ex.getMessage();
	}
}
```

=== Structured concurrency

* forked tasks are children of the scope +
  (visible in thread dumps)
* creates relationship between threads
* success/failure policy can be defined +
  across all children

=== Joiner

Use `Joiner` to configure success/failure policy:

* how are results collected?
* when are subtasks cancelled?
* when does `join` throw?

Pass to `StructuredTaskScope.open(Joiner)`.
