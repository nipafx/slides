== Project Loom
image::images/loom.jpg[background, size=cover]

> JVM features and APIs for supporting easy-to-use, high-throughput, lightweight concurrency and new programming models

Profile:

* https://openjdk.org/projects/loom/[project] /
https://wiki.openjdk.org/display/loom/Main[wiki] /
http://mail.openjdk.org/mailman/listinfo/loom-dev[mailing list]
* launched January 2018
* led by Ron Pressler

=== Motivation

An application with many blocking operations +
had two options:

* block platform (OS) threads until task completion:
** simple-to-use programming paradigm
** can limit throughput
* use asnychronous programming
** harder to write and harder still to debug
** allows higher throughput

=== Motivation

Resolve the conflict between:

* simplicity
* throughput

=== Enter virtual threads!

A _virtual_ thread:

* is a regular `Thread`
* low memory footprint (stack + bytes)
* small switching cost
* scheduled by the Java runtime
* executes on platform thread
* waits in memory +
  (no platform thread blocked)

=== Exceptions

Pinning: ::
* a _pinned_ VT will block the PT
* caused by object monitors, +
  native calls, class initialization

Capture: ::
* a _captured_ VT blocks the PT
* caused by file I/O

=== Object monitor pinning

Object monitor implementation:

* was bound to OS threads
* required deep refactoring +
  to work with VTs
* fix ships with JDK 24

‚áù No more pinning for `synchronized`.

=== Native code pinning

Cause:

* native code works on PT's stack
* switching PTs would wreak havoc

Fix:

* possible in the JVM, but expensive
* fairly easy to avoid

‚áù Don't call native code, then back to Java, then block.

=== File I/O capture

File I/O capture is caused by JVM/OS limitations.

Linux `io_uring` allows async I/O but:

* adoption incurrs overhead
* considerable compared to cached SSD-reads
* cost/benefit is not good

‚áù No fix for now.

=== Performance

Virtual threads aren't "faster threads": +
Each task takes the same time (same _latency_).

Virtual threads increase _throughput_:

* when workload is not CPU-bound _and_
* when number of concurrent tasks is high

=== Use Cases

Virtual threads are cheap and plentiful:

* no pooling necessary
* allows thread per task
* allows liberal creation +
  of threads for subtasks

‚áù Enables new concurrency programming models.

=== Structured programming

* prescribes single entry point +
  and clearly defined exit points
* influenced languages and runtimes

=== Structured concurrency

> When the flow of execution splits into multiple concurrent flows, they rejoin in the same code block.

‚áù Threads are short-lived:

* start when task begins
* end on completion

‚áù Enables parent-child/sibling relationships +
  and logical grouping of threads.

////
=== Unstructured concurrency

```java
void handle(Request request, Response response)
		throws InterruptedException {
	try (var executor = Executors
			.newVirtualThreadPerTaskExecutor()) {
		// what's the relationship between
		// this and the two spawned threads?
		// what happens when one of them fails?
		var futureA = executor.submit(this::taskA);
		var futureB = executor.submit(this::taskB);
		// what if we only need the faster one?
		response.send(futureA.get() + futureB.get());
	} catch (ExecutionException ex) {
		response.fail(ex);
	}
}
```
////

=== Structured concurrency

```java
void handle(Request request, Response response)
		throws InterruptedException {
	// implicitly short-circuits on error
	try (var scope = StructuredTaskScope.open()) {
		var subtaskA = scope.fork(this::taskA);
		var subtaskB = scope.fork(this::taskB);
		// wait explicitly for success
		// (throws errors if there were any)
		scope.join();

		response.send(subtaskA.get() + subtaskB.get());
	} catch (ExecutionException ex) {
		response.fail(ex);
	}
}
```

=== Completion

Use `Joiner` to configure completion:

* how are results collected?
* when are subtasks cancelled?
* when does `join` throw?

Pass to `StructuredTaskScope.open(Joiner)`.

=== Joiners

Existing joiners for heterogeneous results:

* `awaitAllSuccessfulOrThrow()`:
** cancels/throws on first error
** default behavior of `open()`
* `awaitAll()`:
** never cancels/throws

////
=== Await All

```java
try (var scope = StructuredTaskScope
		.open(Joiners.awaitAll())) {
	var subtask = scope.fork(this::task);
	// never throws:
	scope.join();
	switch (subtask.state()) {
		case SUCCESS -> // ...
		case FAILED -> // ...
		case UNAVAILABLE -> // ...
	}
} catch (ExecutionException ex) {
	// [error handling]
}
```
////

=== Joiners

Existing joiners for homogeneous results:

* `allSuccessfulOrThrow()`:
** cancels/throws on first error
** returns `Stream<RESULT>`
* `anySuccessfulResultOrThrow()`
** cancels/throws if all fail
** returns `RESULT`

=== Structured concurrency

* forked tasks are children of the scope +
  (visible in thread dumps)
* creates relationship between threads
* success/failure policy can be defined +
  across all children

=== Sharing data

With `ThreadLocal`:

```java
static final ThreadLocal<Principal> PRINCIPAL =
	new ThreadLocal<>();

public void serve(Request request, Response response) {
	var level = request.isAdmin() ? ADMIN : GUEST;
	var principal = new Principal(level);
	PRINCIPAL.set(principal);
	Application.handle(request, response);
}

// elsewhere
PRINCIPAL.get()
```

=== Sharing data

`ThreadLocal` downsides:

* unconstrained mutability
* unbounded lifetime
* expensive inheritance

`ScopedValues` improve on that:

* write-once (per thread)
* clearly scoped
* free inheritance

=== With scoped value

```java
static final ScopedValue<Principal> PRINCIPAL =
	new ScopedValue<>();

public void serve(Request request, Response response) {
	var level = request.isAdmin() ? ADMIN : GUEST;
	var principal = new Principal(level);
	ScopedValue
		.where(PRINCIPAL, principal)
		.run(() -> Application
			.handle(request, response));
}

// elsewhere
PRINCIPAL.get()
```

=== Project Loom

Virtual threads:

* code is simple to write, debug, profile
* allows high throughput

Structured concurrency:

* clearer concurrency code
* simpler failure/success policies
* better debugging

Scoped values:

* safer, more scalable data sharing

=== Timeline

JDK 21:

* virtual threads finalize (https://openjdk.org/jeps/444[JEP 444])
* structured concurrency previews (https://openjdk.org/jeps/453[JEP 453])
* scoped values preview (https://openjdk.org/jeps/446[JEP 446])

JDK 24:

* object monitors no longer pin virtual threads (https://openjdk.org/jeps/491[JEP 491])
* structured concurrency in 4th preview (https://openjdk.org/jeps/499[JEP 499])
* scoped values in 4th preview (https://openjdk.org/jeps/446[JEP 487])

=== Timeline

Current work:

* finalize structured concurrency and +
  scoped values APIs
* reduce pinning during class initialization
* improve lock info in thread dumps

JDK 25:

* structured concurrency in 5th preview (https://openjdk.org/jeps/499[JEP 499])
* scoped values ü§∑üèæ‚Äç‚ôÇÔ∏è

=== Deeper Dives

* üìù https://inside.java/2021/11/30/on-parallelism-and-concurrency/[On Parallelism and Concurrency]
* üìù https://250bpm.com/blog:71/[Structured Concurrency]
* üìù https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/[Notes on structured concurrency [...\]]
* üé• https://www.youtube.com/watch?v=fq0OEX0XYR8[Modern, Scalable Concurrency for the Java Platform] +
  (Sep 2021)
* üé• https://www.youtube.com/watch?v=KG24inClY2M[State of Project Loom with Ron Pressler] (Jun 2021)
* üé• https://www.youtube.com/watch?v=lKSSBvRDmTg[Java 19 Virtual Threads - JEP Caf√© #11] (Jun 2022)
