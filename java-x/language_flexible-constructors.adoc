== {title}

{toc}

// A quality-of-life improvement.

=== Constructor Chaining

With multiple constructors, +
it's good practice to have one constructor that:

* checks all arguments
* assigns all fields

Other constructors just forward (if possible).

=== Constructor Chaining

```java
class Name {

	private final String first, last;

	Name(String first, String last) {
		// [... checks, assignments, etc. ...]
	}

	Name(String fst, String mid, String lst) {
		this(fst + " " + mid, lst);
	}

}
```

=== Forced Constructor Chaining

Superclasses::
To ensure superclass initialization, chaining +
through `super(...)` is enforced.

Records::
To enforce a uniform construction protocol, +
chaining through `this(...)` to the canonical +
constructor is enforced.

=== Limitations

**But**:

* superclass should be initialized +
  before subclass runs any code +
  ‚áù no code before `super(...)`
* code before `this(...)` would +
  run before `super(...)` +
  ‚áù no code before `this(...)`

So: no statements before `super(...)` / `this(...)`!

=== Consequence

With:

* `class A`
* `class B extends A`
* `class C extends B`

Effective constructor execution for `new C()`:

`Object` ‚áù `A` ‚áù `B` ‚áù `C`

=== Irregularities

```java
Name(String first, String last) {
	this.first = first;
	this.last = last;
	IO.println(this);
}

ThreePartName(String fst, String mid, String lst) {
	super(fst, lst);
	this.middle = mid;
}

new ThreePartName("Jane", "Jennifer", "Doe");
// prints: "Jane null Doe" üòñ
```

=== Inconveniences

Limitation is inconvenient when you want to:

* check arguments
* prepare arguments
* split/share arguments

=== Splitting Arguments

```java
class Name {

	private final String first, last;

	Name(String first, String last) {
		this.first = first;
		this.last = last;
	}

	Name(String full) {
		// less readable & does the same work twice
		this(full.split(" ")[0], full.split(" ")[1]);
	}

}
```
=== Splitting Arguments

Workarounds exist, but what we want to write:

```java
class Name {

	// [... fields, constructor as before ...]

	Name(String full) {
		String[] names = full.split(" ");
		this(names[0], names[1]);
	}

}
```

=== Flexible Constructor Bodies

Flexible constructor bodies allow just that!

```java
Constructor(...) {
	// prologue
	// call to this(...) or super(...)
	// epilogue
}
```

Prologue:

* can't touch `this`
* except to assign fields

=== Consequence

With:

* `class A`
* `class B extends A`
* `class C extends B`

Effective constructor execution for `new C()`:

`prologue C` ‚áù `prologue B` ‚áù `prologue A` +
‚áù `Object` ‚áù +
`epilogue A` ‚áù `epilogue B` ‚áù `epilogue C`

=== Prologue

Great to:

* check arguments
* prepare arguments
* split/share arguments
* assign fields (!)

Fully initializing state in the prologue +
prevents escape of ill-formed instances.

=== Split Arguments

```java
class ThreePartName extends Name {

	private final String middle;

	ThreePartName(String full) {
		// split "first middle last" on space (once üôåüèæ)
		var names = full.split(" ");
		this.middle = names[1];
		super(names[0], names[2]);
	}

}
```

=== Future Expansion

JEP 401 ("Value Classes and Objects") may make +
constructor "prologue by default" for:

* value classes
* all records

Also "anticipates" that regular classes can opt in.

=== More

* üìù https://openjdk.org/jeps/513[JEP 513]: Flexible Constructor Bodies
* üìù https://openjdk.org/jeps/401#Safe-construction-for-value-classes[JEP 401]: Value Classes and Objects ‚áù Safe Construction
* üé• https://www.youtube.com/watch?v=cI-fY9YlmH4[Statements Before `super(...)` and `this(...)`]
* üé• https://www.youtube.com/watch?v=IF9l8fYfSnI[Valhalla - Where Are We?] (Brian Goetz - Aug 2024)
